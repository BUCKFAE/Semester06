\documentclass[14pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{amsthm}
\usepackage[T1]{fontenc}
\usepackage{amsmath}

\title{Algorithmische Graphentheorie}
\author{Julian Schubert}

% Definition
\mdfdefinestyle{theoremstyle}{
    linecolor=blue!50,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=theoremstyle]{definition}{Definition}

% Eigenschaft
\mdfdefinestyle{eigenschaftstyle}{
    linecolor=red!50,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=eigenschaftstyle]{eigenschaft}{Eigenschaft}


% Kopf- / Fußzeile
\makeatletter
\let\runauthor\@author
\let\runtitle\@title
\pagestyle{fancy}
\fancyhf{}
\rhead{\runtitle}
\lhead{\runauthor}
\cfoot{\thepage}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


\begin{document}


\maketitle
\tableofcontents

\newpage
\section{Wichtige Begriffe}
\begin{definition}
    Ein gerichteter Graph $G$ ist \textbf{schwach} zusammenhängend
    wenn der darunterliegende ungerichtete Graph zusammenhängend
    ist \\
    Ein gerichteter Graph $G$ ist \textbf{stark} zusammenhängend
    wenn es für jedes Knotenpaar $(u, v)$ einen gerichteten Weg
    von $u$ nach $v$ gibt
\end{definition}
\begin{definition}[bipartiter Graph]
    Ein Graph G wird as bipartit bezeichnet, wenn sich seine Knoten
    in zwei disjunkte Teilmengen A und B aufteilen lassen. Zwischen
    Den Knoten innerhalb dieser Teilmengen dürfen also keine Kanten
    existieren.
\end{definition}
\section{Eulerkreise}
\begin{definition}[Eulerkreis]
    Sei $G$ ein (un-)gerichteter Grpah. \\
    Ein Eulerkreis (-weg) in
    $G$ ist ein Kreis (Weg), der jede \textbf{Kante} genau
    einmal durchläuft. \\
    Ein Graph heißt \textbf{eulersch}, falls er einen
    Eulerkreis enthält
\end{definition}
Ein Graph der nur einen Eulerweg aber keinen Eulerkreis
enthält, ist nicht eulersch!
\begin{eigenschaft}[Satz von Euler]
    Sei $G$ ein ungerichteter und zsh. Graph.  \\
    Dann gilt:
    $G$ eulersch $\Leftrightarrow$ alle Knoten haben geraden Grad
\end{eigenschaft}
Bei gerichteten Graphen: indeg($v$) = outdeg($v$)
\subsection{Eulerkreis finden}
Man kann in $O(E)$ testen on G eulersch ist (Knotengrade zählen) \\
Eulerkreis finden: \\
Verwalte in jedem Knoten $v$ eien zeiger curr[$v$], der auf
den ersten unbenutzten Nachbarn $w$ zeigt

\section{Hamiltonkreise}
\begin{definition}[Hamiltonkreis NP-schwer]
    Sei $G$ ein (un-)gerichteter Graph. Ein Hamiltonkreis (-weg)
    in $G$ ist ein Kreis (Weg), der jeden \textbf{Knoten} genau
    einmal durchläuft.
\end{definition}
\begin{eigenschaft}[Satz von Bondy und Chvátal]
    Sei $G = (V, E)$ ein ungerichteter Graph mit $|V| \geq 3$ \\
    Seien $u$ und $v$ nicht-adjazente Knoen von G mit deg($u$)
    + deg($v$) $\geq n$ := |V|. Dann gilt: \\
    \indent G hamiltons $\Leftrightarrow$ G + $uv$ hamitlonsch
\end{eigenschaft}
\begin{eigenschaft}[Satz von Dirac]
    Sei G = (V, E) ein ungerichteter Graph mit |V| $\geq$ 3.
    Falls jeder Knoten von G Grad $\geq$ |V| / 2 hat, so ist
    G hamiltonsch
\end{eigenschaft}
TODO: Beweisen

\section{Handlungsreisen (TSP)}
Lösbar mit Algorithmmus von Bellman \& Held-Karp

\section{Lineare Programmierung}
\begin{definition}[Knotenüberdeckung]
    \textbf{Gegeben:} Graph $G = (V, E)$ \\
    \textbf{Gesucht:} Knotenüberdeckung, d.h. $V'
        \subseteq V$, so dass jede Kante mindestens einen
    Endpunkt in $V'$ hat. \\
    \textbf{Ziel:} $|V'|$ minimal
\end{definition}
\begin{definition}[Clique]
    \textbf{Gegeben:} ungerichteter, ungewichteter Graph $G = (V, E)$ \\
    \textbf{Gesucht:} Clique in $G$ \\
    d.h. $V' \subseteq V$, so dass der von $V'$ induzierte Graph
    $G[V']$ vollständig ist (also jeder Knoten eine Verbindung
    zu jedem anderen Knoten hat) \\
    Mit anderen Worten: $V' \subseteq V$, so dass für alle $\{u', v'\}
        \in \binom{V'}{2}$ gilt $u'v' \in E$
\end{definition}

\begin{definition}[Fluss]
    Sei $G = (V, E)$ ein gerichteter Graph mit $s, t \in V$.
    Eine funktion $f : E \rightarrow \mathbb{R}_{\geq 0}$ heißt
    s-t-Fluss (Fluss), wenn für jeden Knoten $v \in V \backslash
        \{ s, t \}$ gilt:
    \[
        \sum_{u \in V | uv \in E} f(uv)
        - \sum_{w \in V vw \in E} f(vw) = 0
    \]
    Zufluss zum knoten V = Abfluss vom Knoten v, also der
    Nettozufluss muss gleich Null sein.
\end{definition}
\begin{definition}
    Sei $G = (V, E)$ ein gerichteter Graph mit $s, t \in V$. \\
    Seien durch $c: E \rightarrow \mathbb{R}_{\geq 0}$ Kantenkapazitäten
    gegeben. Ein Fluss f ist zulässig, wenn für jede Kante $e \in E$ gilt:
    \[
        0 \leq f(e) \leq c(e)
    \]
\end{definition}
Der \textbf{Wert} $|f|$ eines Flusses f ist der Nettozufluss
zum Knoten t.

\section{Flussalgorithmen}
\begin{definition}[Kapazität eines Schnittes]
    G Graph mit Kap. c: $E \rightarrow \mathbb{R}_{> 0}$, (S, T) s-t-Schnitt. \\
    Dann ist c(S) := c(Raus(S)) die \text{Kapazität} von (S, T)
\end{definition}

\subsection{Flussvergrößernde Wege}
\begin{enumerate}
    \item Residualgraph G' bilden:
          \begin{itemize}
              \item Hinrichtung: Benutzte Kapazität in G
              \item Rückrichtung: Übrige Kapazität der Kante
          \end{itemize}
\end{enumerate}
\begin{definition}
    Eins s-t-Weg W in G$_f$ heißt flussvergrößernder Weg für f. \\
    Die Residualkapatziät von W ist
    \[
        \bigtriangleup_W  := min_{e \in W} c_f(e)
    \]
\end{definition}
Ein zulässiger s-t-Fluss in G ist maximal $\Leftrightarrow$ es gibt
keinen Flussvergrößenderen Weg in G$_f$

\begin{definition}[Max-Flow-Min-Cut-Theorem]
    Sei f ein zulässiger s-t-Fluss in einem gerichteten Graphen
    G mit Kapazitäten $c : E \rightarrow \mathbb{R}_{\geq 0}$ \\
    Dann sind folgende Bedingugnen äquivalent:
    \begin{enumerate}
        \item f ist ein maximaler Fluss in G
        \item G$_f$ enthält keine augmentierenden Wege
        \item Es gibt einen s-t-Schnitt (S, T) mit $|f| = c(S)$
    \end{enumerate}
    Kurz \\
    \begin{centering}
        \[
            max_{\text{f zulässiger s-t-Fluss}} |f|
            = min_{\text{(S, T) s-t-Schnitt}} c(S)
        \]
    \end{centering}
\end{definition}

\subsection{Algorithmen}
\begin{definition}[FordFulkerson / EdmonsKarp]
    Suche s-t-weg in G$_f$ und füge das dann den
    Kanten hinzu. \\
    Änderung von EdmonsKarp: Muss der Kürzeste s-t-Weg sein
\end{definition}
EdmonsKarp führt O(VE) Flussvergrößerungen durch \\
EdmonsKarp läuft in O(VE$^2$)
\section{Matchings}
\begin{definition}[Matchings]
    Sei $G = (V, E)$ ein ungerichteter Graph \\
    $M \subseteq E$ ist eine \textbf{Paarung} (engl. matching), wenn je zwei 
    Kanten in M keinen gleichen Endpunkt haben \\
    Falls für jede Kante $e \in M$ gilt, dass $M \cup \{ e \}$ keine 
    Paarung ist, so ist M \textbf{nicht erweiterbar} (engl. maximal) \\
    Falls für alle Parrungen $M'$ in $G$ gilt, dass $|M'| \leq |M|$,
    so ist $M$ eine \textbf{größte Paarung} (engl. maximum) \\
    Falls jeder Knoten in $G$ durch $M$ gepaart ist, so ist M eine 
    \textbf{perfekte Paarung} (engl. perfect matching)
\end{definition}
\begin{definition}[Ganzzahligkeitssatz]
    Sind alle Kapazitäten ganzzahlig, d.h. $c: E \rightarrow \mathbb{N}$, 
    so existiert ein maximaler Fluss, der ganzzahlig ist.
\end{definition}
\begin{eigenschaft}[Satz von Menger]
    Sei $G = (V, E)$ ein gerichteter Graph und $s, t \in V$. Dann ist 
    die maximale Anzahl kantendisjunkter s-t-Wege gleich der minimalen
    Kardinalität eines s-t-Schnittes
\end{eigenschaft}
\textbf{Kardinalität eines s-t-Schnittes}: Anzahl an Kanten die von 
S nach T Laufen. \\
$\Rightarrow$ minimale Kardinalität eines s-t-Schnitts = maximale 
Anzahl an kantendisjunkter s-t-Wege (die Kapazität aller möglichen
s-t-Schnitte ist genau so groß wie die Anzahl an möglichen s-t-Wegen)
\begin{eigenschaft}[Auch von Menger]
    Sei $G = (V, E)$ ein gerichteter Graph, $s, t \in V, st \notin E$.
    Dann ist die maximale Anzahl \textbf{knotendisjunkter} s-t-Wege gleich
    der Kardinalität einer kleinsten Knotenmenge, die s und t trennt.
\end{eigenschaft}
\begin{definition}[Nachbarschaft]
    Nachbarschaft von $v \in V$ ist \\
    \[
        N(v) := \{ u \in V | uv \in E\}  
    \]
    Nachbarschaft von $V' \subseteq V$ ist
    \[
        N(V') := \bigcup_{v' \in V'} N(v')
    \]
\end{definition}
\begin{definition}[Heiratssatz (bewiesen von Philip Hall)]
    Es existiert ein perfektes Matching $\Leftrightarrow$ Für jedes 
    $D' \subseteq D$ gilt: $|D'| \leq |N(D')|$
\end{definition}
\begin{eigenschaft}
    Sei $G = (V, E)$ ein bipartiter Graph \\
    Dann lässt sich eine größte Parrung in G in $O(VE^2)$ Zeit bestimmen
\end{eigenschaft}
In $G'$ können wir $|V|$ s-t-wege in je $O(E)$ zeit berechnen
\section{Alternierende und augmentierende Wege}
\begin{definition}[Augmentierender Weg]
    Ein Weg ist \textbf{augmentierend}, wenn die Kanten immer Abwechselnd im
    Matching und nicht im Matching liegen. Starten und Enden mit einer Kante
    die nicht im Matching liegt.
\end{definition}
\textbf{Alternierend:} Wechselt zwischen im Matching und nicht im Matching
\begin{definition}[Satz von Berge]
    Sei $G = (V, E)$ Grpah, $M \subseteq E$ Matching in G. \\
    M ist ein größtes Matching in G $\Leftrightarrow$ es gibt keinen
    M-augmentierenden Weg.
\end{definition}
\begin{eigenschaft}
    In einem bipartiten Graphen $G = (V, E)$ lässt sich in $O(VE)$ ein größtes
    Matching bestimmen
\end{eigenschaft}
\textbf{Ansatz:} Knoten S erstelen mit Kante zu allen Knoten im einen Teil, dann BFS 
$|V| / 2$ mal ausführen (oder bis kein freier Knoten in B mehr gefunden wird). 
\begin{definition}[Christofides Alfogrithmus]
    \begin{itemize}
        \item Ermittle einen minimalen Spannbaum B für G
        \item Sei U die Menge der Knoten ungeraden Grades in B
        \item Ermittle kostenminimales perfektes Matching M für G[U]
        \begin{itemize}
            \item G[u] ist der von U induzierte Graph
            \item $(U, \{ vw \in E(g): v \in U, w \in U\})$
        \end{itemize}
        \item Berechne im eulerschen Grpahen $B \cup M$ erst Eulertour und dann 
        Rundtour $T$ wie beim Tree-Doubling
    \end{itemize}
    $\Rightarrow$ liefert eine 3/2-Approximation für $\varDelta$-TSP
\end{definition}
\begin{definition}[Kostenminimales perfektes Matching]
    Gegeben: vollständiger Graph $G = (V, E)$, mit Kantenkosten $c: E \rightarrow 
    \mathbb{R}_{\geq 0}$ \\
    Gesucht: Perfektes Matching M mit minimalen Kosten $c(M) = \sum_{e \in M} c(e)$ \\
    $\Rightarrow$ kann in O($V^3$) berechnet werden (ist aber ziemlich kompliziert :(
\end{definition}
\section{Wurzelspannbäume}
\begin{definition}[Wurzelbaum]
    Ein gerichteter Graph $T = (V, E)$ mit Knoten $s \in V$ heißt 
    s-\textbf{Wurzelbaum}, wenn
    \begin{itemize}
        \item T azyklisch
        \item indeg(s) = 0
        \item indeg(v) = 1 für jeden Knoten $ v \in V \backslash \{s\}$
    \end{itemize}
\end{definition}
\begin{definition}[Wurzelspannbaum]
    Sei $G = (V, E)$ ein gerichteter (Multi-) Graph mit Knoten $s \in V$.
    Ein Teilgraph T von G mit Knotenmenge V heißt s-\textbf{Wurzelspannbaum}
    von G, wenn T ein s-Wurzelbaum ist.
\end{definition}
\begin{eigenschaft}
    Sei G ein gerichteter (Multi-) Graph mit Knoten s \\
    G besitzt einen s-Wurzelspannbaum $\Leftrightarrow$ jeder Knoten $v \in V$
    ist von s in G erreichbar. \\
    DFS(s) liefert s-Wurzelspannbaum (falls es einen gibt)
\end{eigenschaft}
\begin{eigenschaft}
    Sei K Kreis in F und $\tilde{T}$ s-Wurzellspannbaum von G/K. \\
    Dann gibt es einen s-Wurzelspannbaum T von G mit \\
    \[
        c'(T) \leq c'(\tilde{T})  
    \]
    G/K: K sie Teilmenge von G. Alle Knoten in K werden durch einen einzigen 
    Ersetzt.
\end{eigenschaft}
Algorithmus zur berechnung von s-Wurzelspannbäumen:
\begin{itemize}
    \item Berechne modifizierte Kantenkosten $c'$
    \item Bestimme Teilgraph F
    \item Falls F azyklisch, gib F zurück
    \item Ansonsten ermittle Kreis K in F
    \item Kontrahiere G zu G / K
    \item Wende Algo rekursiv auf (G/K, c') and
    \begin{itemize}
        \item s-Wurzelspannbaum für $\tilde{T}$ für G/K
    \end{itemize}
    \item Expandiere $\tilde{T}$ zu s-Wurzelspannbaum T von G
    \item Gibt T zurück
\end{itemize}
\end{document}