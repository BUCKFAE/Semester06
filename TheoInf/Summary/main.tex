\documentclass[14pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{amsthm}
\usepackage[T1]{fontenc}

\title{Theoretische Informatik}
\author{Julian Schubert}

% Definition
\mdfdefinestyle{theoremstyle}{
    linecolor=blue!50,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=theoremstyle]{definition}{Definition}

% Eigenschaft
\mdfdefinestyle{eigenschaftstyle}{
    linecolor=red!50,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=eigenschaftstyle]{eigenschaft}{Eigenschaft}


% Kopf- / Fußzeile
\makeatletter
\let\runauthor\@author
\let\runtitle\@title
\pagestyle{fancy}
\fancyhf{}
\rhead{\runtitle}
\lhead{\runauthor}
\cfoot{\thepage}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


\begin{document}


    \maketitle
    \tableofcontents

    \newpage

    \section{Wichtige Vermutungen}
    \begin{definition}[Goldbachsche Vermutung]
        Jede natürliche gerade Zahl größer 2 ist Summe zweier Primzahlen
    \end{definition}
    \begin{definition}[Collaz-Problem (3n +1)-Vermutung]
        \begin{itemize}
            \item Beginne mit irgendeiner natürlichen Zahl $n > 0$
            \item Ist n gerade, son imm als nächstes $n // 2$ (abrundende Division)
            \item Wiederhole das Vorgehen mit der erhaltenen Zahl
        \end{itemize}
        \noindent
        \textbf{Vermutung:} Jede so konstruierte Zahlenfolge mündet in den Zyklus
            4, 2, 1, egal mit welcher natürlichen zahl $n > 0$ beginnt
    \end{definition}
    
    \section{Elementare Begriffe}

        \subsection{Komplexitätsklassen}
        \[
            ALL \subset P \subset NP
        \]
        \begin{itemize}
            \item \textbf{ALL:} Alle Probleme
            \item \textbf{NP:} Probleme, deren Lösungen schnell übrprüft weden können
                (effizient überprüfbare Probleme)
            \item \textbf{P:} Probleme, die isch in polynomieller Zeit lösen lassen 
                (effizient lösbare Probleme)
        \end{itemize}

        \subsection{Funktionen}
        \begin{definition}[Funktionen]
            Seien $f: A \rightarrow B$ und $g : B \rightarrow C$ Funktionen
            \begin{itemize}
                \item \textbf{Definitionsbereich} von f: \\
                $D_f = \{a \in A |$ es existiert ein $ b \in B$ mit $f(a) = b$\} \\
                $\Rightarrow$ Alles was etwas im Wertebereich trifft
                \item \textbf{Wertebereich} von f: \\
                $D_f = \{a \in A |$ es existiert ein $ a \in A$ mit $f(a) = b$\} \\
                $\Rightarrow$ alles was von etwas im Definitionsbereich 
                getroffen wird
                \item \textbf{Total:} $D_f = A$
                \item \textbf{Surjektiv:} $W_f = B$
                \item \textbf{Injektiv:} aus $a_1, a_2 \in D$ und $a_1 \neq a_2$
                folgt $f(a_1) \neq f(a_2)$
                \item \textbf{Bijektiv:} $f$ ist total, surjektiv und injektiv
                \item ist $f$ injektiv, so existiert die \textbf{Umkehrfunktion}
                $f^{-1}: B \rightarrow A$ mit $f^{-1}(b) = $ dasjenige $a  \in A$
                mit $f(a) = b$
            \end{itemize}
        \end{definition}

        \subsection{Binärdarstellung}
        \begin{definition}
            Jede natürliche Zahl $n \geq 1$ ist in genau einer Weise darstellbar
            als 
            \[
                n = \sum_{i = 0}^m a_i \cdot 2^i
            \]
            mit $m \in \mathbb{N}, a_m = 1$ und $a_0, \dots, a_{m - 1} 
            \in \{0, 1\}$.
        \end{definition}
        \begin{eigenschaft}[Binärdarstellung]
            \begin{center}
            $bin(2n + a) = bin(n)a$ für $n \geq 1$ und $a \in  \{0, 1\}$ 
            \end{center}
        \end{eigenschaft}

        \subsection{Listencodierung}
        Liste von Binärzahlen: $\langle x_1, \dots, x_n \rangle$ \\
        \textbf{Anwendung:} Bits verdoppeln, 10 alss Anfangs-, Trenn- und Enmarkierung
        \textbf{Beispiele:} \\
        $
            \indent \langle \rangle = bin^{-1}(10) = 2 \\
            \indent \langle 2 \rangle = bin^{-1}(10110010) = 178 \\
            \indent \langle 5, 3, 2 \rangle = bin^{-1}(1011001110111110110010) = 2944946
        $
    \section{While}
    \begin{definition}[While-Berechenbarkeit]
        Eine Funktion ist dann \textbf{While-Berechenbar}, falls es 
        ein While-Programm gibt, sodass der Definitionsbereich von 
        beiden identisch ist und der Wert für alle Eingaben übereinstimmt.
    \end{definition}
    \begin{definition}[Loop-Programm]
        ein \textbf{Loop-Programm} ist ein While-Programm mit folgenden
        Eigenschaften: 
        \begin{itemize}
            \item Das Programm enthält keine While-Schleifen
            \item Aus einer Funktion können nur weiter oben deklarierte
            Funktionen aufgerufen werden. Insbesondere sind keine 
            Selbstaufrufe erlaubt
            \item Das Programm enhält nur Funktionsdeklarationen mit 
            Initialiserung
        \end{itemize}
    \end{definition}
\end{document}