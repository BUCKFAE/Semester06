\documentclass[14pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{mathabx}

\title{Theoretische Informatik}
\author{Julian Schubert}

% Definition
\mdfdefinestyle{theoremstyle}{
    linecolor=blue!20,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=theoremstyle]{definition}{Definition}

% Eigenschaft
\mdfdefinestyle{eigenschaftstyle}{
    linecolor=red!50,
    linewidth=2pt,
    frametitlerule=true,
    frametitlebackgroundcolor=gray!20,
    innertopmargin=\topskip
}
\mdtheorem[style=eigenschaftstyle]{eigenschaft}{Eigenschaft}


% Kopf- / Fußzeile
\makeatletter
\let\runauthor\@author
\let\runtitle\@title
\pagestyle{fancy}
\fancyhf{}
\rhead{\runtitle}
\lhead{\runauthor}
\cfoot{\thepage}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


\begin{document}


\maketitle
\tableofcontents

\newpage

\section{Wichtige Vermutungen}
\begin{definition}[Goldbachsche Vermutung]
    Jede natürliche gerade Zahl größer 2 ist Summe zweier Primzahlen
\end{definition}
\begin{definition}[Collaz-Problem (3n +1)-Vermutung]
    \begin{itemize}
        \item Beginne mit irgendeiner natürlichen Zahl $n > 0$
        \item Ist n gerade, so nimm als nächstes $n // 2$ (abrundende Division)
        \item ist n ungerade, so nimm als nächstes $3n + 1$
        \item Wiederhole das Vorgehen mit der erhaltenen Zahl
    \end{itemize}
    \noindent
    \textbf{Vermutung:} Jede so konstruierte Zahlenfolge mündet in den Zyklus
    4, 2, 1, egal mit welcher natürlichen zahl $n > 0$ beginnt
\end{definition}
\begin{definition}[Ackermann-Funktion]
    \textbf{Frage:} Gilt LOOP = $\{f \in$ WHILE | $f$ ist total\}? \\
    Die folgende Funktion (auch \textbf{Ackermann-Funktion} genannt)
    $a: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}$ ist
    total und While-berechenbar, aber nicht Loop-berechenbar: \\
    \begin{equation*}
        a(n, m) =
        \begin{cases}
            m + 1                 & \text{falls $n = 0$}             \\
            a(n - 1, 1)           & \text{falls $n > 0$ und $m = 0$} \\
            a(n - 1, a(n, m - 1)) & \text{falls $n > 0$ und $m > 0$}
        \end{cases}
    \end{equation*}
    $\Rightarrow$ Die Ackermann-Funktion ist eine totale Funktion in
    $WHILE-LOOP$
\end{definition}

\begin{definition}[Hauptsatz der Algorithmentheorie]
    $RAM = WHILE = MINIWHILE = TM$
\end{definition}

\begin{definition}[Curch-Turing These]
    Auch: These von Church: \\
    Turing-Berechenbarkeit erfasst den intitiven Begriff der
    Berechenbarkeit.
\end{definition}
\section{Elementare Begriffe}

\subsection{Komplexitätsklassen}
\[
    ALL \subset P \subset NP
\]
\begin{itemize}
    \item \textbf{ALL:} Alle Probleme
    \item \textbf{NP:} Probleme, deren Lösungen schnell übrprüft weden können
          (effizient überprüfbare Probleme)
    \item \textbf{P:} Probleme, die isch in polynomieller Zeit lösen lassen
          (effizient lösbare Probleme)
\end{itemize}

\subsection{Funktionen}
\begin{definition}[Funktionen]
    Seien $f: A \rightarrow B$ und $g : B \rightarrow C$ Funktionen
    \begin{itemize}
        \item \textbf{Definitionsbereich} von f: \\
              $D_f = \{a \in A |$ es existiert ein $ b \in B$ mit $f(a) = b$\} \\
              $\Rightarrow$ Alles was etwas im Wertebereich trifft
        \item \textbf{Wertebereich} von f: \\
              $D_f = \{a \in A |$ es existiert ein $ a \in A$ mit $f(a) = b$\} \\
              $\Rightarrow$ alles was von etwas im Definitionsbereich
              getroffen wird
        \item \textbf{Total:} $D_f = A$
        \item \textbf{Surjektiv:} $W_f = B$
        \item \textbf{Injektiv:} aus $a_1, a_2 \in D$ und $a_1 \neq a_2$
              folgt $f(a_1) \neq f(a_2)$
        \item \textbf{Bijektiv:} $f$ ist total, surjektiv und injektiv
        \item ist $f$ injektiv, so existiert die \textbf{Umkehrfunktion}
              $f^{-1}: B \rightarrow A$ mit $f^{-1}(b) = $ dasjenige $a  \in A$
              mit $f(a) = b$
    \end{itemize}
\end{definition}

\subsection{Binärdarstellung}
\begin{definition}
    Jede natürliche Zahl $n \geq 1$ ist in genau einer Weise darstellbar
    als
    \[
        n = \sum_{i = 0}^m a_i \cdot 2^i
    \]
    mit $m \in \mathbb{N}, a_m = 1$ und $a_0, \dots, a_{m - 1}
        \in \{0, 1\}$.
\end{definition}
\begin{eigenschaft}[Binärdarstellung]
    \begin{center}
        $bin(2n + a) = bin(n)a$ für $n \geq 1$ und $a \in  \{0, 1\}$
    \end{center}
\end{eigenschaft}

\subsection{Listencodierung}
Liste von Binärzahlen: $\langle x_1, \dots, x_n \rangle$ \\
\textbf{Anwendung:} Bits verdoppeln, 10 alss Anfangs-, Trenn- und Enmarkierung
\textbf{Beispiele:} \\
$
    \indent \langle \rangle = bin^{-1}(10) = 2 \\
    \indent \langle 2 \rangle = bin^{-1}(10110010) = 178 \\
    \indent \langle 5, 3, 2 \rangle = bin^{-1}(1011001110111110110010) = 2944946
$

\section{While-Programme}
\begin{definition}[While-Berechenbarkeit]
    Eine Funktion ist dann \textbf{While-Berechenbar}, falls es
    ein While-Programm gibt, sodass der Definitionsbereich von
    beiden identisch ist und der Wert für alle Eingaben übereinstimmt.
\end{definition}
\begin{definition}[Loop-Programm]
    ein \textbf{Loop-Programm} ist ein While-Programm mit folgenden
    Eigenschaften:
    \begin{itemize}
        \item Das Programm enthält keine While-Schleifen
        \item Aus einer Funktion können nur weiter oben deklarierte
              Funktionen aufgerufen werden. Insbesondere sind keine
              Selbstaufrufe erlaubt
        \item Das Programm enhält nur Funktionsdeklarationen mit
              Initialiserung
        \item Das Programm ist für alle Eingaben definiert
    \end{itemize}
\end{definition}
$\Rightarrow$ Alle Loop-berechenbaren Funktionen sind total.
\subsection{Berechnende Funktion bestimmen}
\begin{enumerate}
    \item Schauen für welche Eingabe(n) die Schleife(n) wie oft
          ausgeführt werden
    \item Schauen was sich mit jedem Schleifendurchlauf verändert
\end{enumerate}


\section{Ram-Programme}
\begin{definition}[modifizierte Differenz]
    \begin{equation*}
        x \dotdiv y =  md(x, y)
        \begin{cases}
            x - y & \text{falls $x > y$} \\
            0     & \text{sonst}
        \end{cases}
    \end{equation*}
\end{definition}

\section{Alphabete und Wörter}
\begin{definition}[Alphabete und Wörter]
    \begin{itemize}
        \item Ein \textbf{Alphabet} ist eine endliche, nichtleere Menge
        \item Die Elemente eines Alphabets werden \textbf{Buchstaben}
              oder \textbf{Symbole} genannt
        \item Ein \textbf{Wort über einem Alphabet $\varSigma$} ist eine
              endliche Folge von 0 oder mehr Elementen aus $\varSigma$
        \item das \textbf{leere Wort} (d.h. das Wort, das aus 0 Buchstaben)
              besteht bezeichnen wir mit $\varepsilon$
    \end{itemize}
\end{definition}
\begin{definition}[Mengen von Wörtern]
    Sei $\varSigma$ ein Alphabet, $n \geq 0$ und $a_1, a_2, \dots a_n
        \in \varSigma$
    \begin{itemize}
        \item Die \textbf{Länge eines Wortes} w $a_1a_2\dots a_n$ ist
              $|w| = n$
        \item \textbf{Menge aller Wörter mit Länge n:} \\
              $\varSigma^n = \{ w | w \text{ ist ein Wort über $\varSigma$
                      mit $|w| = n$} \}$ \\
              Es gilt $\varSigma^0 = \{ \varepsilon \}$
        \item \textbf{Menge aller Wörter:} \\
              $\varSigma^* = \{ w | w \text{ ist ein Wort über $\varSigma$}\}
                  = \bigcup_{u\geq 0} \varSigma^n \text{ und } \varSigma^+
                  = \varSigma^* \backslash \{ \varepsilon \} $
        \item eine \textbf{formale Sprache über} $\varSigma$ ist
              eine Teilmenge von $\varSigma^*$
        \item Das \textbf{Entscheidungsproblem} einer formalen Sprache
              $L \subseteq \varSigma^*$ ist folgende Aufagbe: \\
              Eingabe: $w \in \varSigma^*$ \\
              Ausgabe: \\
              1, falls $w \in L$ \\
              0, falls $w \notin L$
    \end{itemize}
\end{definition}
\begin{definition}[Dyadische dartstellung]
    dya: $\mathbb{N} \rightarrow \{ 1, 2\}^*$ ist definiert durch
    \begin{itemize}
        \item dya(0) = $\varepsilon$
        \item day(n) = $a_m \dots a_0$ falls $n \geq 1, n = \sum_{i = 0}^m
                  a_i \cdot 2^i$ und $a_0, \dots, a_m \in \{ 1, 2 \}$
    \end{itemize}
\end{definition}

\begin{eigenschaft}[k-adische Darstellung]
    Sei $k \geq 2$
    \begin{enumerate}
        \item ad$_k$(kn + a) = ad$_k$(n)a für $n \geq 0$ und $a \in \{ 1, \dots k\}$
        \item ad$_k$$^{-1}$(xa) = k $\cdot$ ad$_k$$^{-1}$(x) + a
                      für $x \in \{ 1, \dots, k\}^*, a \in \{ 1, \dots, k \}$
    \end{enumerate}
\end{eigenschaft}

\section{Turing-Maschinen}
\begin{definition}[Turing Maschiene]
    Sei $k \geq 1$. Eine \textbf{k-Band-Turing-Maschine} ist
    ein Quintupel $(\varSigma, Z, f, z_0, z_1)$ mit
    \begin{itemize}
        \item $\varSigma$ ist eine endliche Menge (Alphabet)
        \item $Z$ ist eine endliche Menge (Zustandsmenge)
        \item $f(Z \backslash \{ z_1\}) \times \varSigma^k \rightarrow
                  Z \times \varSigma^k \times \{ L, O, R \}^k$ ist eine totale Funktion
              (Überführungsfunktion)
        \item $z_0 \in Z$ (Startzustand)
        \item $z_1 \in Z$ (Stoppzustand)
    \end{itemize}
    $M(z, a_1 \dots a_m)$: Wort das auf Band 1 steht, alle anderen
    Bänder leer, und $a \in \varSigma \backslash \{ \text{Leersymbol} \}$
\end{definition}
\begin{definition}[Palindrom]
    Ein wort $a_1 \dots a_n$ heißt symmetrisch oder auch
    \textbf{Palindrom}, falls $a_1 \dots a_n = a_n \dots a_1$
\end{definition}

\section{Laufzeit von Algorithmen}
\begin{definition}[Länge einer Zahl]
    \[
        |x| = |dya(abs(x))|
    \]
\end{definition}

\section{Entscheidbarkeit und Aufzählbarkeit}
\begin{definition}[Entscheidungsalgorithmus]
    Entscheidungsalgorithmus für eine Menge A: \\
    \indent Eingabe x $\Rightarrow$ Ausgabe
    $
        \begin{cases}
            1 \text{ (ja),}   & \text{falls } x \in A    \\
            0 \text{ (nein),} & \text{falls } x \notin A
        \end{cases}
    $ \\
    Dies ist die berechnung der \textbf{charakteristischen Funktion}
    von A ($c_A(x)$).
\end{definition}
\textbf{Semicharakteristische Funktion}: \\
Wie characteristische Funktion, nur n.d. falls $x \notin A$ ($\chi_A(x)$)
\begin{definition}[Entscheidbarkeit]
    Seien $n \geq 0$ und $t: \mathbb{N} \rightarrow \mathbb{N}$ eine
    totale Funktion:
    \begin{itemize}
        \item $A \subseteq \mathbb{N}^n$ heißt \textbf{entscheidbar}
              $\Leftrightarrow$ $c_A$ ist berechenbar
        \item $A \subseteq \mathbb{N}^n$ heißt \textbf{semientscheidbar}
              $\Leftrightarrow$ $\chi_A(x)$ ist berechenbar
        \item \textbf{REC} $= \{ A | \exists n\geq 0 \text{ mit } A
                  \subseteq \mathbb{N}^n \text{ und A ist entscheidbar}\}$
              (recursive languages), also alle berechenbaren Mengen
        \item Ein Algorithmus \textbf{M entscheidet A} $\subseteq
                  \mathbb{N}^n$ \textbf{in der Zeit t (bzw. O(t))} $\Leftrightarrow$
              M berechnet $c_A$ in der Zeit t (bzw. O(t))
    \end{itemize}
\end{definition}
\begin{eigenschaft}
    Fär $A \subseteq \mathbb{N}^n$ gilt: \\
    \begin{center}
        A entscheidbar $\Leftrightarrow$ A und $\bar{A}$ semientscheidbar \\
        A entscheidbar $\Leftrightarrow$ A und $\bar{A}$ aufzählbar \\
        A aufzählbar $\Leftrightarrow$ $B \subseteq \mathbb{N}^n \times \mathbb{N}$
        mit $A = Pr(B)$
    \end{center}
\end{eigenschaft}
\begin{definition}[Aufzählbarkeit]
    $A \subseteq \mathbb{N}^n$ mit $n \geq 0$ heißt \textbf{rekursiv aufzählbar}
    (kurz: aufzählbar) $\Leftrightarrow$ $A = \emptyset$ oder es gibt ein
    berechenbares, totales $f: \mathbb{N} \rightarrow \mathbb{N}^n$ mit
    $W_f = A$ \\
    \textbf{RE} Alle Mengen die Aufzählbar sind
\end{definition}
\begin{eigenschaft}
    Für $m, n \geq 0$ gilt: \\
    \indent $f: \mathbb{N}^m \rightarrow \mathbb{N}^n$ berechenbar, total
    $\Rightarrow$ $W_F$ ist aufzählbar
\end{eigenschaft}
\begin{eigenschaft}
    Für A $\subseteq \mathbb{N}^n$ sind folgende Aussagen äquivalent
    \begin{enumerate}
        \item A ist aufzählbar
        \item A ist semientscheidbar
        \item A ist Definitionsbereich einer berechenbaren Funktion
              $f: \mathbb{N}^n \rightarrow \mathbb{N}^m$ mit $m \geq 0$
        \item A ist Wertebereich einer berechenbaren Funktion
              $g: \mathbb{N}^m \rightarrow \mathbb{N}^n$ mit $m \geq 0$
    \end{enumerate}
\end{eigenschaft}
\begin{definition}[Projektion]
    Die \textbf{Projektion} einer Menge \\
    $B \subseteq \mathbb{N}^n \times \mathbb{N}$ ist definiert als $Pr(B) =
        \{ x \in \mathbb{N}^n | \exists y \in \mathbb{N}[(x, y) \in B ]\}$
\end{definition}
\begin{definition}[Reduzierbarkeit]
    Seien $A \subseteq \mathbb{N}^n$ und $B \subseteq \mathbb{N}^n$. \\
    \textbf{A ist reduzierbar auf B} $\Leftrightarrow$ es gibt ein totales,
    berechenbares $f: \mathbb{N}^m \rightarrow \mathbb{N}^n$ sodass für
    alle $x \in \mathbb{N}^m$ gilt:
    \[
        x \in A \Leftrightarrow f(x) \in B
    \]
    Die Äquivalenz ist gleichbedeutend mit den Aussagen $c_A = c_b \circ
        f$ und $\chi_A = \chi_B \circ f$
\end{definition}
\begin{eigenschaft}
    Seien $A \subseteq \mathbb{N}^m$ und $B \subseteq \mathbb{N}^n$. Falls
    A reduzierbar auf B ist, so gelten folgende Implikationen:
    \\
    $
        B \in REC \Rightarrow B \in REC \\
        B \in RE \Rightarrow A \in RE
    $
\end{eigenschaft}
\begin{definition}[Gödelisierung]
    Skritp ab Seite 172, Rams werden als Liste codiert.
\end{definition}
\begin{definition}[Halteproblem]
    $K_0 = \{ x | M_x \text{ hält bei Eingabe x}\}$
    \textbf{spezielles Halteproblem} \\
    $K = \{ (x, y) | M_x \text{ hält bei Eingabe y}\}$
    \textbf{allgemeines Halteproblem} \\
    $\Rightarrow$ wir geben der Maschiene ihren eigenen Quellcode
    als Eingabe \\
    $K_0$ ist aufzählbar, aber nicht entscheidbar
\end{definition}
\begin{definition}[Satz von Rice]
    Die Frage, ob die von einem gegebenen Quelltext berechnete Funktion
    eine Eigenschaft S hat, lässt sich nicht Algorithmisch lösen
\end{definition}
\begin{definition}
    Seien $\mathbb{G}$ eine Grundmenge, $A \subseteq \mathbb{G}$
    und $t: \mathbb{N} \rightarrow \mathbb{N}$ eine totale Funktion
    \begin{itemize}
        \item A heißt \textbf{entscheidbar} $\Leftrightarrow$ $c_A :
                  \mathbb{G} \rightarrow \{ 0, 1\}$ ist berechenbar
        \item A heißt \textbf{semientscheidbar} $\Leftrightarrow$ $\chi_A :
                  \mathbb{G} \rightarrow \{ 0, 1\}$ ist berechenbar
        \item A heißt \textbf{rekursiv aufzählbar} (kurz: aufzählbar)
              $\Leftrightarrow$ $A = \emptyset$ oder es gibt ein berechenbares,
              totales $f: \mathbb{N} \rightarrow \mathbb{G}$ mit $W_f = A$
    \end{itemize}
\end{definition}

\section{Endliche Automaten}
\begin{definition}[Deterministischer endlicher Automat]
    Ein \textbf{deterministischer endlicher Automat (DEA)} ist ein
    Quintupel $(\varSigma, Z, \delta, z_0, F)$ mit folgenden Eigenschaften:
    \begin{itemize}
        \item $\varSigma$ ist eine endliche, nichtleere Menge (Eingabealphabet)
        \item $Z$ ist eine endliche Menge (Zustandsmenge)
        \item $\delta$ ist eine totale Funktion $Z \times \varSigma \rightarrow Z$
              (Überführungsfunktion)
        \item $z_0 \in Z$ (Startzustand)
        \item $F \subseteq Z$ (Menge der akzeptierenden Zustände)
    \end{itemize}
\end{definition}
\begin{definition}[Erweiterte Überführungsfunktion]
    Die \textbf{erweiterte Überführungsfunktion} eines DEA A = $(\varSigma, Z, \delta,
        z_0, F)$ ist die wie folg definierte Abbildung $\bar{\delta} : Z \times
        \varSigma^* \rightarrow Z$. \\
    (IA) $\bar{\delta}(z, \epsilon) = z$ für alle $z \in Z$ \\
    (IS) $\bar{\delta} = \delta(\bar{\delta}(z, w), a)$ für alle $z \in Z, w \in
        \varSigma^*, a \in \varSigma$ \\
    \\
    Damit gilt: $\bar{\delta}(z, w) = $ Zustand, den der DEA erreicht wenn er in
    z startet und das Wort w einliest.
\end{definition}
\begin{definition}[Akzeptierung von Sprachen durch DEAs]
    \begin{itemize}
        \item Ein wort $w \in \varSigma^*$ heißt \textbf{von A akzeptiert} $\Leftrightarrow
                  \bar{\delta}(z_0, w) \in F$
        \item Die von \textbf{A akzeptierte Sprache} ist
              \[
                  \text{\textbf{L(A)}} = \{ w \in \varSigma^* | \text{ w wird von
                      A akzeptiert}\}
              \]
        \item Die \textbf{Menge der von DEAs akzeptierten Sprachen ist}
              \[
                  \text{\textbf{EA}} = \{ L(A) | \text{ A ist ein DEA}\}
              \]
    \end{itemize}
\end{definition}
$\Rightarrow$ eine $L \in EA$ sind \textbf{entscheidbar}
\section{Nichtdeterministische endliche Automaten}
Unterschied DEA: \\
$\delta$ ist eine totale Funktion $Z \times \varSigma \rightarrow P(Z)$, also
eine Abbildung auf die Potenzmenge. \\
Kann in mehreren Zuständen gleichzeitig sein. \\
\\
Erweiterte Überführungsfunktion: $\bar{\delta}(z, w)$ = Menge der Zustände, die der NEA
gleichzeitig erreicht, wenn er in z startet und das Wort w einliest. \\
\\
Die von NEAS akzeptierte Sprache heißt \textbf{L(A)}
\begin{definition}[Potenzmengenkonstruktion]
    Aus DEA einen NEA machen
\end{definition}
\begin{definition}[Konkatenation von Sprachen]
    Seien L, L' $\subseteq \varSigma^*$
    \begin{align*}
        L \cdot L' & = \{ uv | u \in L \text{ und } v \in L' \} \\
        L^0         & = \{ \epsilon \} \\
        L^{k + 1} &= L \cdot L^k \text{ für } k \geq 0 \\
        L^* &= \bigcup_{k \geq 0} L^k = \{ u_1u_2 \dots u_m 
        | m \geq 0 \text{ und } u_1, \dots u_m \in L \}
    \end{align*}
\end{definition}
\begin{definition}[Abschlusseigenschaften von EA]
    \[
        L, L' \in EA \Rightarrow \bar{L}, L \cup L', L \cap L', L \cdot L', L^* \in EA  
    \]
\end{definition}
\section{Reguläre Ausdrücke}
\begin{definition}[Syntax und Semantik regulärer Ausdrücke]
    Sei $\varSigma$ ein Alphabet. Wir definieren \textbf{reguläre Ausdrücke} $\gamma$ und
    die durch sie beschriebenen Sprachen $L(\gamma)$. \\
    \begin{itemize}
        \item (IA) $\emptyset, \epsilon$ und \textbf{a} sind reguläre Ausdrücke (wobei $
        a \in \varSigma$). \\
        Semantik: $L(\emptyset) = \emptyset, L(\epsilon) = \{\epsilon\}, L(a) =\{a\}$
        \item (IS) sind $\alpha, \beta$ reguläre ausdrücke, so auch $(\alpha + \beta), 
        (\alpha \cdot \beta), \alpha^*$ \\
        Semantik: \\
        $L(\alpha + \beta) = L(\alpha) \cup L(\beta)$ \\
        $L(\alpha \cdot \beta) = L(\alpha) \cdot L(\beta)$ \\
        $L(\alpha^*) = L(\alpha)^*$
    \end{itemize} 
    \begin{enumerate}
        \item Unnötige Klammern un $\cdot$ können weggelassen werden
        \item Bindungsreihensfolge: * -> $\cdot$ -> + \\
        $0 + 01^*$ steht also für $(0 + (0 \cdot (1^*)))$
        \item Bezeichnung reg. Ausdrücke durch griechische Kleinbuchstaben
    \end{enumerate}
\end{definition}
\begin{definition}[Reguläre Sprachen]
    \begin{itemize}
        \item Eine Sprache L heißt \textbf{regulär} $\Leftrightarrow$ es 
        existiert ein regulärer Ausdruck $\alpha$ mit $L = L(\alpha)$
        \item \textbf{REG} = $\{ L | L \text{ ist regulär}\}$
    \end{itemize}
\end{definition}
\begin{eigenschaft}
    Seien $L, A, B \subseteq \varSigma^*$ mit $\epsilon \notin A$. Falls
    $L = A \cdot L \cup B$, so gilt $L = A^* B$
\end{eigenschaft}
\section{Pumping-Lemma}
\begin{eigenschaft}
    Für jede reguläre Sprache L existiert ein $n \in \mathbb{N}^+$ mit folgender
    Eigenschaft: \\
    Jedes Wort $w \in L$ mit $|w| \geq n$ lässt sich zerlegen in $w = xyz$, sodass
    $y \neq \epsilon, |xy| \leq n$ und $\forall_{i \geq 0} xy^iz \in L$
\end{eigenschaft}
\begin{definition}[Äquivalenz von Zuständen]
    Sei $A = (\varSigma, Z, \delta, z_0, F)$ ein DEA. Zwei Zustände $z_1, z_2 \in Z$
    heißen \textbf{äquivalent}, falls für alle $w \in \varSigma^*$ gilt:
    \[
        \bar{\delta}(z_1, w) \in F \Leftrightarrow \bar{\delta}(z_2, w) \in F   
    \]
\end{definition}
\begin{definition}[unterscheidbare Zustandspaare]
    Sei $A = (\varSigma, Z, \delta, z_0, F)$ ein DEA.
    \begin{itemize}
        \item (IA) falls $z_1 \in F \Leftrightarrow z_2 \in F$ so sind $z_1$ und $z_2$
        \textbf{unterscheidbar}
        \item (IS) Sind $a \in \varSigma$, $\delta(z_1, a) = z'_1, \delta(z_2, a) = z'_2$
        sowie $z'_1$ und $z'_2$ unterscheidbare Zustände, so sind $z_1$ und $z_2$ 
        \textbf{unterscheidbar}
    \end{itemize}
\end{definition}
\begin{eigenschaft}
    Sei $A = (\varSigma, Z, \delta, z_0, F)$ ein DEA. 
    Sind zwei Zustände $z_1, z_2 \in Z$ nicht unterscheidbar $\Leftrightarrow$ so sind sie äquivalent
\end{eigenschaft}
\begin{definition}[Äquivalente DEA]
    \text{EquivalentDEA} = $\{(A_1, A_2) | A_1, A_2$ sind DEAS mit gleichem
    Eingabealphabet und $L(A_1) = L(A_2)\}$
\end{definition}
\begin{enumerate}
    \item Wir fassen $A_1$ und $A_2$ als einen DEA auf, indem wir beide
    Automaten nebeneinander zeichen und als Startzustand den von $A_1$ wählen
    \item Bestimme die unterscheidbaren Zustände mit Hilfe des Algorithmus 
    auf seite 234
    \item $A_1$ und $A_2$ sind genau dann äquivalent, wenn die beiden Start-
    zustände nicht unterscheidbar sind
\end{enumerate}
\begin{eigenschaft}
    Sei $A = (\varSigma, Z, \delta, z_0, F)$ ein DEA. Die Äquivalenz von
    Zuständen ist eine Äquivalenzrelation auf Z, d.h. es gilt:
    \begin{enumerate}
        \item Jeder Zustand ist sich selbst äquivalent (Reflexivität)
        \item Ist p äquivalent zu q so auf q zu p (Symmetrie)
        \item Ist p äquivalent zu q und q äquivalent zu r, so auf p zu r
        (Transitivität)
    \end{enumerate}
\end{eigenschaft}
TODO: S.246
\end{document}